"""
Patch Manager - AI Self-Improvement Code Modification System

Manages AI-generated patch requests for self-improvement:
1. Receives patch requests from the self-improvement loop
2. Validates against protected files (gate system)
3. Logs requests to database with PENDING_APPROVAL status
4. Applies approved patches
5. Tracks success/failure of applications

This ensures AI can propose code changes but requires human approval
before any modifications are made to the codebase.

Part of Phase 4: Advanced Self-Improvement
"""

import uuid
import difflib
import json
from datetime import datetime
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from pathlib import Path
from enum import Enum

from loguru import logger

from ..storage.database import DatabaseManager, PatchRequestRepository


class PatchStatus(Enum):
    """Status of a patch request"""
    PENDING_APPROVAL = "PENDING_APPROVAL"
    APPROVED = "APPROVED"
    DENIED = "DENIED"
    APPLIED = "APPLIED"
    FAILED = "FAILED"


@dataclass
class PatchRequest:
    """A patch request generated by the AI"""
    request_id: str
    target_file: str
    reasoning: str
    diff: str
    new_code_blob: str
    component: str
    improvement_type: str
    confidence: float
    feedback_ids: List[str]
    metrics: Dict[str, Any]
    created_at: datetime


@dataclass
class PatchApproval:
    """Result of human approval/denial"""
    request_id: str
    approved: bool
    reviewed_by: str
    review_comment: Optional[str] = None


class PatchManager:
    """
    Patch Manager - Handles AI code modification requests

    This is the "Request Log" component that manages pending patch requests.
    It receives requests from the self-improvement loop, stores them,
    and applies them after human approval.
    """

    def __init__(
        self,
        db_manager: DatabaseManager,
        protected_files: Optional[List[str]] = None,
        auto_approve_threshold: float = 0.95,  # Only auto-approve very high confidence
        enable_auto_approve: bool = False  # Default: require human approval
    ):
        """
        Initialize Patch Manager

        Args:
            db_manager: Database manager for persistence
            protected_files: List of files that cannot be modified
            auto_approve_threshold: Confidence threshold for auto-approval
            enable_auto_approve: Whether to enable auto-approval at all
        """
        self.db_manager = db_manager
        self.patch_repository = PatchRequestRepository(db_manager)

        # Protected kernel files that cannot be modified
        self.protected_files = protected_files or [
            "src/ai_pal/gates/gate_system.py",
            "src/ai_pal/modules/ethics.py",
            "src/ai_pal/improvement/patch_manager.py",  # This file itself
            "src/ai_pal/core/config.py",  # System configuration
        ]

        self.auto_approve_threshold = auto_approve_threshold
        self.enable_auto_approve = enable_auto_approve

        logger.info(
            f"Patch Manager initialized with {len(self.protected_files)} protected files, "
            f"auto-approve: {enable_auto_approve}"
        )

    async def submit_patch_request(
        self,
        target_file: str,
        reasoning: str,
        original_code: str,
        new_code: str,
        component: str,
        improvement_type: str,
        confidence: float,
        feedback_ids: Optional[List[str]] = None,
        metrics: Optional[Dict[str, Any]] = None
    ) -> Optional[PatchRequest]:
        """
        Submit a patch request for approval

        Args:
            target_file: File to be modified
            reasoning: Natural language explanation of why this change is needed
            original_code: Current code content
            new_code: Proposed new code content
            component: Which component is being improved
            improvement_type: Type of improvement (from ImprovementAction)
            confidence: AI's confidence in this change (0-1)
            feedback_ids: List of feedback event IDs that motivated this change
            metrics: Performance metrics that motivated this change

        Returns:
            PatchRequest if accepted, None if rejected by gate system
        """
        logger.info(
            f"Patch request submitted for {target_file} by {component}, "
            f"confidence: {confidence:.2f}"
        )

        # Gate System Check: Is this file protected?
        if self._is_protected_file(target_file):
            logger.warning(
                f"Patch request DENIED by gate system: {target_file} is protected. "
                f"Request silently rejected."
            )
            return None

        # Generate diff
        diff = self._generate_diff(original_code, new_code, target_file)

        # Create request
        request_id = str(uuid.uuid4())
        request = PatchRequest(
            request_id=request_id,
            target_file=target_file,
            reasoning=reasoning,
            diff=diff,
            new_code_blob=new_code,
            component=component,
            improvement_type=improvement_type,
            confidence=confidence,
            feedback_ids=feedback_ids or [],
            metrics=metrics or {},
            created_at=datetime.now()
        )

        # Save to database
        await self._save_request(request)

        logger.info(
            f"Patch request {request_id} saved with status PENDING_APPROVAL"
        )

        # Check for auto-approval
        if self.enable_auto_approve and confidence >= self.auto_approve_threshold:
            logger.info(
                f"Patch request {request_id} qualifies for auto-approval "
                f"(confidence: {confidence:.2f} >= {self.auto_approve_threshold})"
            )
            approval = PatchApproval(
                request_id=request_id,
                approved=True,
                reviewed_by="auto_approve_system",
                review_comment=f"Auto-approved based on high confidence ({confidence:.2f})"
            )
            await self.process_approval(approval)

        return request

    def _is_protected_file(self, target_file: str) -> bool:
        """
        Check if file is in the protected kernel

        Protected files cannot be modified by the AI, ensuring
        the core ethical framework remains intact.
        """
        # Normalize path for comparison
        normalized_target = Path(target_file).as_posix()

        for protected in self.protected_files:
            normalized_protected = Path(protected).as_posix()

            # Check exact match or if target is within protected directory
            if normalized_target == normalized_protected or \
               normalized_target.startswith(normalized_protected + "/"):
                return True

        return False

    def _generate_diff(
        self,
        original_code: str,
        new_code: str,
        filename: str
    ) -> str:
        """Generate unified diff between original and new code"""
        original_lines = original_code.splitlines(keepends=True)
        new_lines = new_code.splitlines(keepends=True)

        diff = difflib.unified_diff(
            original_lines,
            new_lines,
            fromfile=f"a/{filename}",
            tofile=f"b/{filename}",
            lineterm=""
        )

        return "".join(diff)

    async def _save_request(self, request: PatchRequest) -> None:
        """Save patch request to database"""
        request_data = {
            "request_id": request.request_id,
            "created_at": request.created_at,
            "target_file": request.target_file,
            "reasoning": request.reasoning,
            "diff": request.diff,
            "new_code_blob": request.new_code_blob,
            "component": request.component,
            "improvement_type": request.improvement_type,
            "confidence": request.confidence,
            "status": PatchStatus.PENDING_APPROVAL.value,
            "feedback_ids": json.dumps(request.feedback_ids),
            "metrics": json.dumps(request.metrics)
        }

        await self.patch_repository.save_request(request_data)

    async def get_pending_requests(
        self,
        limit: Optional[int] = None
    ) -> List[Dict[str, Any]]:
        """
        Get all pending patch requests

        This is used by the dashboard to show requests awaiting approval.
        """
        return await self.patch_repository.get_pending_requests(limit=limit)

    async def get_request(self, request_id: str) -> Optional[Dict[str, Any]]:
        """Get specific patch request by ID"""
        return await self.patch_repository.get_request(request_id)

    async def process_approval(self, approval: PatchApproval) -> bool:
        """
        Process human approval/denial of a patch request

        Args:
            approval: Approval decision from human reviewer

        Returns:
            True if patch was applied successfully (if approved), False otherwise
        """
        request = await self.get_request(approval.request_id)

        if not request:
            logger.error(f"Patch request {approval.request_id} not found")
            return False

        if request["status"] != PatchStatus.PENDING_APPROVAL.value:
            logger.warning(
                f"Patch request {approval.request_id} already processed "
                f"(status: {request['status']})"
            )
            return False

        if approval.approved:
            logger.info(
                f"Patch request {approval.request_id} APPROVED by {approval.reviewed_by}"
            )

            # Update status to APPROVED
            await self.patch_repository.update_status(
                approval.request_id,
                PatchStatus.APPROVED.value,
                approval.reviewed_by,
                approval.review_comment
            )

            # Apply the patch
            success = await self._apply_patch(request)

            if success:
                logger.info(
                    f"Patch request {approval.request_id} APPLIED successfully"
                )
                await self.patch_repository.update_status(
                    approval.request_id,
                    PatchStatus.APPLIED.value
                )
            else:
                logger.error(
                    f"Patch request {approval.request_id} FAILED to apply"
                )

            return success

        else:
            logger.info(
                f"Patch request {approval.request_id} DENIED by {approval.reviewed_by}"
            )

            # Update status to DENIED
            await self.patch_repository.update_status(
                approval.request_id,
                PatchStatus.DENIED.value,
                approval.reviewed_by,
                approval.review_comment
            )

            return False

    async def _apply_patch(self, request: Dict[str, Any]) -> bool:
        """
        Apply an approved patch to the filesystem

        This performs the actual file I/O to overwrite the target file.

        Args:
            request: Approved patch request

        Returns:
            True if successful, False otherwise
        """
        target_file = request["target_file"]
        new_code = request["new_code_blob"]

        try:
            # Resolve file path
            file_path = Path(target_file)

            # Ensure parent directory exists
            file_path.parent.mkdir(parents=True, exist_ok=True)

            # Create backup of original file
            if file_path.exists():
                backup_path = file_path.with_suffix(file_path.suffix + ".backup")
                backup_path.write_text(file_path.read_text())
                logger.info(f"Created backup: {backup_path}")

            # Write new code
            file_path.write_text(new_code)

            logger.info(f"Successfully applied patch to {target_file}")
            return True

        except Exception as e:
            error_msg = f"Failed to apply patch to {target_file}: {str(e)}"
            logger.error(error_msg, exc_info=True)

            # Record error in database
            await self.patch_repository.record_application_error(
                request["request_id"],
                error_msg
            )

            return False

    async def get_request_history(
        self,
        status: Optional[str] = None,
        limit: int = 50
    ) -> List[Dict[str, Any]]:
        """
        Get request history

        Args:
            status: Filter by status (None = all)
            limit: Maximum number of requests to return

        Returns:
            List of patch requests
        """
        if status:
            return await self.patch_repository.get_requests_by_status(
                status=status,
                limit=limit
            )
        else:
            # Get all recent requests (pending first, then others)
            pending = await self.patch_repository.get_pending_requests(limit=limit)
            applied = await self.patch_repository.get_requests_by_status(
                status=PatchStatus.APPLIED.value,
                limit=limit
            )
            denied = await self.patch_repository.get_requests_by_status(
                status=PatchStatus.DENIED.value,
                limit=limit
            )
            failed = await self.patch_repository.get_requests_by_status(
                status=PatchStatus.FAILED.value,
                limit=limit
            )

            # Combine and sort by created_at
            all_requests = pending + applied + denied + failed
            all_requests.sort(key=lambda x: x["created_at"], reverse=True)

            return all_requests[:limit]

    def get_protected_files(self) -> List[str]:
        """Get list of protected files that cannot be modified"""
        return self.protected_files.copy()

    async def add_protected_file(self, file_path: str) -> None:
        """
        Add a file to the protected list

        Args:
            file_path: Path to file to protect
        """
        if file_path not in self.protected_files:
            self.protected_files.append(file_path)
            logger.info(f"Added {file_path} to protected files list")

    async def remove_protected_file(self, file_path: str) -> None:
        """
        Remove a file from the protected list

        Args:
            file_path: Path to file to unprotect
        """
        if file_path in self.protected_files:
            self.protected_files.remove(file_path)
            logger.info(f"Removed {file_path} from protected files list")
